{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 一致性测试"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For most problems, multiple flux states can achieve the same optimum and thus we try to obtain a consistent network. By this, we mean that there will be mulitple blocked reactions in the network, which gives rise to this inconsistency. To solve this problem, we use algorithms which can detect all the blocked reactions and also give us consistent networks.\n",
    "\n",
    "对于大多数问题，多个通量状态可以达到相同的最优值，所以我们可以尝试获得一个一致的网络。以此，我们的意思是网络中可能会有多个被阻止的反应，这导致了不一致性。为了解决这个问题，我们使用算法来检查所有被阻止的反应，给我们一致的网络。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let us take a toy network, like so:\n",
    "\n",
    "让我们构建一个玩具网络：\n",
    "\n",
    "\\begin{align}\n",
    "v_1 &: {} \\rightarrow 2A \\\\\n",
    "v_2 &: A \\leftrightarrow B \\\\\n",
    "v_3 &: A \\rightarrow D \\\\\n",
    "v_4 &: A \\rightarrow C \\\\\n",
    "v_5 &: C \\rightarrow D \\\\\n",
    "v_6 &: D \\rightarrow\n",
    "\\end{align}\n",
    "\n",
    "Here, $v_{x}$, where $x \\in \\{1, 2, \\ldots, 6\\}$ represent the flux carried by the reactions as shown above.\n",
    "\n",
    "这里 $v_{x}$, $x \\in \\{1, 2, \\ldots, 6\\}$ 表示由以上反应带来的通量"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import cobra"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "unknown metabolite 'A' created\n",
      "unknown metabolite 'B' created\n",
      "unknown metabolite 'D' created\n",
      "unknown metabolite 'C' created\n"
     ]
    }
   ],
   "source": [
    "test_model = cobra.Model(\"test_model\")\n",
    "v1 = cobra.Reaction(\"v1\")\n",
    "v2 = cobra.Reaction(\"v2\")\n",
    "v3 = cobra.Reaction(\"v3\")\n",
    "v4 = cobra.Reaction(\"v4\")\n",
    "v5 = cobra.Reaction(\"v5\")\n",
    "v6 = cobra.Reaction(\"v6\")\n",
    "\n",
    "test_model.add_reactions([v1, v2, v3, v4, v5, v6])\n",
    "\n",
    "v1.reaction = \"-> 2 A\"\n",
    "v2.reaction = \"A <-> B\"\n",
    "v3.reaction = \"A -> D\"\n",
    "v4.reaction = \"A -> C\"\n",
    "v5.reaction = \"C -> D\"\n",
    "v6.reaction = \"D ->\"\n",
    "\n",
    "v1.bounds = (0.0, 3.0)\n",
    "v2.bounds = (-3.0, 3.0)\n",
    "v3.bounds = (0.0, 3.0)\n",
    "v4.bounds = (0.0, 3.0)\n",
    "v5.bounds = (0.0, 3.0)\n",
    "v6.bounds = (0.0, 3.0)\n",
    "\n",
    "test_model.objective = v6"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 使用 FVA"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The first approach we can follow is to use FVA (Flux Variability Analysis) which among many other applications, is used to detect blocked reactions. The `cobra.flux_analysis.find_blocked_reactions()` function will return a list of all the blocked reactions obtained using FVA.\n",
    "\n",
    "我们可以使用的第一步是 FVA，它在其他各种应用中用来检查被阻止的反应。`cobra.flux_analysis.find_blocked_reactions()` 函数会返回一个使用 FVA 获得的，包含所有被阻止的反应的列表。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['v2']"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cobra.flux_analysis.find_blocked_reactions(test_model)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As we see above, we are able to obtain the blocked reaction, which in this case is $v_2$.\n",
    "\n",
    "正如我们以上看到的那样，我们可以获得被阻止的反应，这里是 $v_2$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 使用 FASTCC"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The second approach to obtaining consistent network in `cobrapy` is to use FASTCC. Using this method, you can expect to efficiently obtain an accurate consistent network. For more details regarding the algorithm, please see [Vlassis N, Pacheco MP, Sauter T (2014)](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1003424).\n",
    "\n",
    "第二种在 `cobrapy` 中获得一致网络的方式是使用 FASTCC。使用这种方法，你可以期待高效获取一个准确的一致的网络。关于此算法的更多细节，详见 [Vlassis N, Pacheco MP, Sauter T (2014)](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1003424)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<Reaction v1 at 0x7fc71ddea5c0>,\n",
       " <Reaction v3 at 0x7fc71ddea630>,\n",
       " <Reaction v4 at 0x7fc71ddea668>,\n",
       " <Reaction v5 at 0x7fc71ddea6a0>,\n",
       " <Reaction v6 at 0x7fc71ddea6d8>]"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "consistent_model = cobra.flux_analysis.fastcc(test_model)\n",
    "consistent_model.reactions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Similar to the FVA approach, we are able to identify that $v_2$ is indeed the blocked reaction.\n",
    "\n",
    "与 FVA 方法相似，我们可以看到 $v_2$ 是被阻止的反应。"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.6"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": false,
   "sideBar": true,
   "skip_h1_title": true,
   "title_cell": "Table of Contents",
   "title_sidebar": "Table of Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": true
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
